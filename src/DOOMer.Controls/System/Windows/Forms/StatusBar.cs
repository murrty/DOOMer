//----------------------
// <auto-generated>
//     Backwards compatibility with StatusBars.
// </auto-generated>
//----------------------

#nullable enable
namespace System.Windows.Forms;

#if NETCOREAPP3_1_OR_GREATER && ENABLE_LEGACY_MENUS
using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Drawing;
using System.Globalization;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Windows.Forms.Natives;
using System.Windows.Forms.VisualStyles;

/// <summary>
///     Represents a Windows status bar control.
/// </summary>
[ComVisible(true), ClassInterface(ClassInterfaceType.AutoDispatch), DefaultEvent("PanelClick"), DefaultProperty("Text")]
internal class StatusBar : Control {
    private int sizeGripWidth = 0;
    private const int SIMPLE_INDEX = 0xFF;

    private static readonly object EVENT_PANELCLICK = new();
    private static readonly object EVENT_SBDRAWITEM = new();

    private bool showPanels;
    private bool layoutDirty;
    private int panelsRealized;
    private bool sizeGrip = true;
    private string? simpleText;
    private Point lastClick = new(0, 0);
    private readonly ArrayList panels = [ ];
    private StatusBarPanelCollection? panelsCollection;
    private ControlToolTip? tooltips;

    private ToolTip? mainToolTip;
    private bool toolTipSet;

    /// <summary>
    ///     Initializes a new default instance of the <see cref='StatusBar'/> class.
    /// </summary>
    public StatusBar() : base() {
        base.SetStyle(ControlStyles.UserPaint | ControlStyles.Selectable, false);

        this.Dock = DockStyle.Bottom;
        this.TabStop = false;
    }

    private static VisualStyleRenderer? renderer;

    /// <summary>
    ///     A VisualStyleRenderer we can use to get information about the current UI theme
    /// </summary>
    private static VisualStyleRenderer? VisualStyleRenderer {
        get {
            if (VisualStyleRenderer.IsSupported) {
                renderer ??= new VisualStyleRenderer(VisualStyleElement.ToolBar.Button.Normal);
            }
            else {
                renderer = null;
            }
            return renderer;
        }
    }

    private int SizeGripWidth {
        get {
            if (this.sizeGripWidth == 0) {
                if (Application.RenderWithVisualStyles && VisualStyleRenderer != null) {
                    // VSWhidbey 207045: need to build up accurate gripper width to avoid cutting off other panes.
                    VisualStyleRenderer vsRenderer = VisualStyleRenderer;
                    VisualStyleElement thisElement;
                    Size elementSize;

                    // gripper pane width...
                    thisElement = VisualStyleElement.Status.GripperPane.Normal;
                    vsRenderer.SetParameters(thisElement);
                    elementSize = vsRenderer.GetPartSize(Graphics.FromHwndInternal(this.Handle), ThemeSizeType.True);
                    this.sizeGripWidth = elementSize.Width;

                    // ...plus gripper width
                    thisElement = VisualStyleElement.Status.Gripper.Normal;
                    vsRenderer.SetParameters(thisElement);
                    elementSize = vsRenderer.GetPartSize(Graphics.FromHwndInternal(this.Handle), ThemeSizeType.True);
                    this.sizeGripWidth += elementSize.Width;

                    // Either GetPartSize could have returned a width of zero, so make sure we have a reasonable number:
                    this.sizeGripWidth = Math.Max(this.sizeGripWidth, 16);
                }
                else {
                    this.sizeGripWidth = 16;
                }
            }
            return this.sizeGripWidth;
        }
    }

    /// <summary>
    ///     The background color of this control. This is an ambient property and will always return a non-null value.
    /// </summary>
    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public override Color BackColor {
        get {
            // not supported, always return CONTROL
            return SystemColors.Control;
        }

        set {
            // no op, not supported.
        }
    }

    /// <internalonly/>
    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
    new public event EventHandler BackColorChanged {
        add {
            base.BackColorChanged += value;
        }
        remove {
            base.BackColorChanged -= value;
        }
    }

    /// <summary>
    ///     Gets or sets the image rendered on the background of the <see cref='StatusBar'/> control.
    /// </summary>
    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public override Image? BackgroundImage {
        get {
            return base.BackgroundImage;
        }
        set {
            base.BackgroundImage = value;
        }
    }

    /// <internalonly/>
    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
    new public event EventHandler BackgroundImageChanged {
        add {
            base.BackgroundImageChanged += value;
        }
        remove {
            base.BackgroundImageChanged -= value;
        }
    }

    /// <summary>
    ///    [To be supplied.]
    /// </summary>
    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public override ImageLayout BackgroundImageLayout {
        get {
            return base.BackgroundImageLayout;
        }
        set {
            base.BackgroundImageLayout = value;
        }
    }

    /// <internalonly/>
    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
    new public event EventHandler BackgroundImageLayoutChanged {
        add {
            base.BackgroundImageLayoutChanged += value;
        }
        remove {
            base.BackgroundImageLayoutChanged -= value;
        }
    }

    /// <summary>
    ///     Returns the CreateParams used to create the handle for this control.
    ///     Inheriting classes should call base.getCreateParams in the manor below:
    /// </summary>
    protected override CreateParams CreateParams {
        get {
            CreateParams cp = base.CreateParams;
            cp.ClassName = NativeMethods.WC_STATUSBAR;

            if (this.sizeGrip) {
                cp.Style |= NativeMethods.SBARS_SIZEGRIP;
            }
            else {
                cp.Style &= (~NativeMethods.SBARS_SIZEGRIP);
            }
            cp.Style |= NativeMethods.CCS_NOPARENTALIGN | NativeMethods.CCS_NORESIZE;

            return cp;
        }
    }

    protected override ImeMode DefaultImeMode {
        get {
            return ImeMode.Disable;
        }
    }

    /// <summary>
    ///     Deriving classes can override this to configure a default size for their control.
    ///     This is more efficient than setting the size in the control's constructor.
    /// </summary>
    protected override Size DefaultSize {
        get {
            return new Size(100, 22);
        }
    }

    /// <summary>
    ///     This property is overridden and hidden from statement completion
    ///     on controls that are based on Win32 Native Controls.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected override bool DoubleBuffered {
        get {
            return base.DoubleBuffered;
        }
        set {
            base.DoubleBuffered = value;
        }
    }

    /// <summary>
    ///     Gets or sets the docking behavior of the <see cref='StatusBar'/> control.
    /// </summary>
    [Localizable(true), DefaultValue(DockStyle.Bottom)]
    public override DockStyle Dock {
        get {
            return base.Dock;
        }
        set {
            base.Dock = value;
        }
    }

    /// <summary>
    ///     Gets or sets the font the <see cref='StatusBar'/> control will use to display information.
    /// </summary>
    [Localizable(true), AllowNull]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public override Font Font {
        get => base.Font;
        set {
            base.Font = value;
            this.SetPanelContentsWidths(false);
        }
    }

    /// <summary>
    ///     Gets or sets the forecolor for the control.
    /// </summary>
    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public override Color ForeColor {
        get {
            return base.ForeColor;
        }
        set {
            base.ForeColor = value;
        }
    }

    /// <internalonly/>
    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
    new public event EventHandler ForeColorChanged {
        add {
            base.ForeColorChanged += value;
        }
        remove {
            base.ForeColorChanged -= value;
        }
    }

    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    new public ImeMode ImeMode {
        get {
            return base.ImeMode;
        }
        set {
            base.ImeMode = value;
        }
    }

    /// <internalonly/>
    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
    public new event EventHandler ImeModeChanged {
        add {
            base.ImeModeChanged += value;
        }
        remove {
            base.ImeModeChanged -= value;
        }
    }

    /// <summary>
    ///     Gets the collection of <see cref='StatusBar'/> panels contained within the control.
    /// </summary>
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content), Localizable(true), MergableProperty(false)]
    public StatusBarPanelCollection Panels {
        get {
            this.panelsCollection ??= new StatusBarPanelCollection(this);
            return this.panelsCollection;
        }
    }

    /// <summary>
    ///     The status bar text.
    /// </summary>
    [Localizable(true)]
    [AllowNull]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public override string Text {
        get => this.simpleText ?? "";
        set {
            this.SetSimpleText(value);
            if (this.simpleText != value) {
                this.simpleText = value;
                this.OnTextChanged(EventArgs.Empty);
            }
        }
    }

    /* No one is calling this, so it is ok to comment it out
    private IntPtr ToolTipHandle {
        get {
            EnumChildren c = new EnumChildren( this );
            UnsafeNativeMethods.EnumChildWindows(new HandleRef(null, UnsafeNativeMethods.GetDesktopWindow()), new NativeMethods.EnumChildrenProc(c.Callback), NativeMethods.NullHandleRef);
            return c.hWndFound;
        }
    }
    */

    /// <summary>
    ///     Gets or sets a value indicating whether panels should be shown.
    /// </summary>
    [DefaultValue(false)]
    public bool ShowPanels {
        get => this.showPanels;
        set {
            if (this.showPanels != value) {
                this.showPanels = value;

                this.layoutDirty = true;
                if (this.IsHandleCreated) {
                    int bShowPanels = (!this.showPanels) ? 1 : 0;

                    //SendMessage(NativeMethods.SB_SIMPLE, bShowPanels, 0);
                    UnsafeNativeMethods.SendMessage(new HandleRef(this, this.Handle), NativeMethods.SB_SIMPLE, bShowPanels, 0);

                    if (this.showPanels) {
                        this.PerformLayout();
                        this.RealizePanels();
                    }
                    else if (this.tooltips != null) {
                        for (int i = 0; i < this.panels.Count; i++) {
                            this.tooltips.SetTool(this.panels[i], null);
                        }
                    }

                    this.SetSimpleText(this.simpleText);
                }
            }
        }
    }

    /// <summary>
    ///     Gets or sets a value indicating whether a sizing grip will be rendered on the corner of the <see cref='StatusBar'/> control.
    /// </summary>
    [DefaultValue(true)]
    public bool SizingGrip {
        get {
            return this.sizeGrip;
        }
        set {
            if (value != this.sizeGrip) {
                this.sizeGrip = value;
                this.RecreateHandle();
            }
        }
    }

    /// <summary>
    ///     Gets or sets a value indicating whether the user will be able to tab to the <see cref='StatusBar'/> .
    /// </summary>
    [DefaultValue(false)]
    new public bool TabStop {
        get {
            return base.TabStop;
        }
        set {
            base.TabStop = value;
        }
    }

    internal bool ToolTipSet {
        get {
            return this.toolTipSet;
        }
    }

    internal ToolTip? MainToolTip {
        get {
            return this.mainToolTip;
        }
    }

    /// <summary>
    ///     Occurs when a visual aspect of an owner-drawn status bar changes.
    /// </summary>
    public event EventHandler<StatusBarDrawItemEventArgs> DrawItem {
        add {
            this.Events.AddHandler(EVENT_SBDRAWITEM, value);
        }
        remove {
            this.Events.RemoveHandler(EVENT_SBDRAWITEM, value);
        }
    }

    /// <summary>
    ///     Occurs when a panel on the status bar is clicked.
    /// </summary>
    public event EventHandler<StatusBarPanelClickEventArgs> PanelClick {
        add {
            this.Events.AddHandler(EVENT_PANELCLICK, value);
        }
        remove {
            this.Events.RemoveHandler(EVENT_PANELCLICK, value);
        }
    }

    /// <summary>
    ///     StatusBar Onpaint.
    /// </summary>
    /// <internalonly/><hideinheritance/>
    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
#pragma warning disable RCS1159 // Use EventHandler<T>.
    public new event PaintEventHandler Paint {
        add {
            base.Paint += value;
        }
        remove {
            base.Paint -= value;
        }
    }
#pragma warning restore RCS1159 // Use EventHandler<T>.

    /// <summary>
    ///     Tells whether the panels have been realized.
    /// </summary>
    /// <internalonly/>
    internal bool ArePanelsRealized() {
        return this.showPanels && this.IsHandleCreated;
    }

    /// <internalonly/>
    internal void DirtyLayout() {
        this.layoutDirty = true;
    }

    /// <summary>
    ///     Makes the panel according to the sizes in the panel list.
    /// </summary>
    /// <internalonly/>
    private void ApplyPanelWidths() {
        // This forces handle creation every time any time the StatusBar
        // has to be re-laidout.
        if (!this.IsHandleCreated) {
            return;
        }

        StatusBarPanel panel;
        int length = this.panels.Count;

        if (length == 0) {
            Size sz = this.Size;
            int[] offsets = [ sz.Width ];
            if (this.sizeGrip) {
                offsets[0] -= this.SizeGripWidth;
            }
            UnsafeNativeMethods.SendMessage(new HandleRef(this, this.Handle), NativeMethods.SB_SETPARTS, 1, offsets);
            //SendMessage(NativeMethods.SB_SETICON, 0, IntPtr.Zero);
            UnsafeNativeMethods.SendMessage(new HandleRef(this, this.Handle), NativeMethods.SB_SETICON, 0, IntPtr.Zero);

            return;
        }

        int[] offsets2 = new int[length];
        int currentOffset = 0;
        for (int i = 0; i < length; i++) {
            panel = (StatusBarPanel)this.panels[i]!;

            currentOffset += panel.Width;
            offsets2[i] = currentOffset;
            panel.Right = offsets2[i];
        }
        UnsafeNativeMethods.SendMessage(new HandleRef(this, this.Handle), NativeMethods.SB_SETPARTS, length, offsets2);

        // Tooltip setup...
        //
        for (int i = 0; i < length; i++) {
            panel = (StatusBarPanel)this.panels[i]!;
            this.UpdateTooltip(panel);
        }

        this.layoutDirty = false;
    }

    /// <internalonly/>
    protected override void CreateHandle() {
        if (!this.RecreatingHandle) {
            IntPtr userCookie = UnsafeNativeMethods.ThemingScope.Activate();

            try {
                NativeMethods.INITCOMMONCONTROLSEX icc = new() {
                    dwICC = NativeMethods.ICC_BAR_CLASSES
                };
                SafeNativeMethods.InitCommonControlsEx(icc);
            }
            finally {
                UnsafeNativeMethods.ThemingScope.Deactivate(userCookie);
            }
        }

        base.CreateHandle();
    }

    /// <summary>
    ///     Disposes this control
    /// </summary>
    protected override void Dispose(bool disposing) {
        if (disposing) {
            if (this.panelsCollection != null) {
                StatusBarPanel[] panelCopy = new StatusBarPanel[this.panelsCollection.Count];
                ((ICollection)this.panelsCollection).CopyTo(panelCopy, 0);
                this.panelsCollection.Clear();

                foreach (StatusBarPanel p in panelCopy) {
                    p.Dispose();
                }
            }
        }
        base.Dispose(disposing);
    }

    /// <summary>
    ///     Forces the panels to be updated, location, repainting, etc.
    /// </summary>
    /// <internalonly/>
    private void ForcePanelUpdate() {
        if (this.ArePanelsRealized()) {
            this.layoutDirty = true;
            this.SetPanelContentsWidths(true);
            this.PerformLayout();
            this.RealizePanels();
        }
    }

    /// <summary>
    ///     Raises the <see cref='Control.CreateHandle'/> event.
    /// </summary>
    protected override void OnHandleCreated(EventArgs e) {
        base.OnHandleCreated(e);
        if (!this.DesignMode) {
            this.tooltips = new ControlToolTip(this);
        }

        if (!this.showPanels) {
            //SendMessage(NativeMethods.SB_SIMPLE, 1, 0);
            UnsafeNativeMethods.SendMessage(new HandleRef(this, this.Handle), NativeMethods.SB_SIMPLE, 1, 0);
            this.SetSimpleText(this.simpleText);
        }
        else {
            this.ForcePanelUpdate();
        }
    }

    /// <summary>
    ///     Raises the <see cref='OnHandleDestroyed'/> event.
    /// </summary>
    protected override void OnHandleDestroyed(EventArgs e) {
        base.OnHandleDestroyed(e);
        if (this.tooltips != null) {
            this.tooltips.Dispose();
            this.tooltips = null;
        }
    }

    /* Not used
    /// <summary>
    /// </summary>
    private sealed class EnumChildren {

        public IntPtr hWndFound = IntPtr.Zero;

        private StatusBar peer;

        public EnumChildren( StatusBar peer ) {
            if (peer == null)
                throw new ArgumentNullException("peer");
            this.peer = peer;
        }

        public bool Callback(IntPtr hWnd, IntPtr lparam) {
            if (UnsafeNativeMethods.GetParent(new HandleRef(null, hWnd)) == peer.Handle) {
                hWndFound = hWnd;
                return false;
            }

            return true;
        }
    }*/

    /// <summary>
    ///     Raises the <see cref='OnMouseDown'/> event.
    /// </summary>
    protected override void OnMouseDown(MouseEventArgs e) {
        this.lastClick.X = e.X;
        this.lastClick.Y = e.Y;
        base.OnMouseDown(e);
    }

    /// <summary>
    ///     Raises the <see cref='OnPanelClick'/> event.
    /// </summary>
    protected virtual void OnPanelClick(StatusBarPanelClickEventArgs e) {
        EventHandler<StatusBarPanelClickEventArgs>? handler = (EventHandler<StatusBarPanelClickEventArgs>?)this.Events[EVENT_PANELCLICK];
        handler?.Invoke(this, e);
    }

    /// <summary>
    ///     Raises the Layout event.
    /// </summary>
    protected override void OnLayout(LayoutEventArgs levent) {
        if (this.showPanels) {
            this.LayoutPanels();
            if (this.IsHandleCreated && this.panelsRealized != this.panels.Count) {
                this.RealizePanels();
            }
        }
        base.OnLayout(levent);
    }

    /// <summary>
    ///     This function sets up all the panel on the status bar according to the internal this.panels List.
    /// </summary>
    /// <internalonly/>
    internal void RealizePanels() {
        StatusBarPanel panel;
        int length = this.panels.Count;
        int old = this.panelsRealized;

        this.panelsRealized = 0;

        if (length == 0) {
            //SendMessage(NativeMethods.SB_SETTEXT, 0, "");
            UnsafeNativeMethods.SendMessage(new HandleRef(this, this.Handle), NativeMethods.SB_SETTEXT, 0, "");
        }

        int i;
        for (i = 0; i < length; i++) {
            panel = (StatusBarPanel)this.panels[i]!;
            if (panel is null) {
                continue;
            }
            try {
                panel.Realize();
                this.panelsRealized++;
            }
            catch {
            }
        }
        for (; i < old; i++) {
            UnsafeNativeMethods.SendMessage(new HandleRef(this, this.Handle), NativeMethods.SB_SETTEXT, 0, (string?)null);
            //SendMessage(NativeMethods.SB_SETTEXT, 0, null);
        }
    }

    /// <summary>
    ///     Remove the internal list of panels without updating the control.
    /// </summary>
    /// <internalonly/>
    internal void RemoveAllPanelsWithoutUpdate() {
        int size = this.panels.Count;
        // remove the parent reference
        for (int i = 0; i < size; i++) {
            StatusBarPanel sbp = (StatusBarPanel)this.panels[i]!;
            if (sbp is null) {
                continue;
            }
            sbp.ParentInternal = null;
        }

        this.panels.Clear();
        if (this.showPanels) {
            this.ApplyPanelWidths();
            this.ForcePanelUpdate();
        }
    }

    /// <summary>
    ///     Sets the widths of any panels that have the
    ///     StatusBarPanelAutoSize.CONTENTS property set.
    /// </summary>
    /// <internalonly/>
    internal void SetPanelContentsWidths(bool newPanels) {
        int size = this.panels.Count;
        bool changed = false;
        for (int i = 0; i < size; i++) {
            StatusBarPanel sbp = (StatusBarPanel)this.panels[i]!;
            if (sbp.AutoSize == StatusBarPanelAutoSize.Contents) {
                int newWidth = sbp.GetContentsWidth(newPanels);
                if (sbp.Width != newWidth) {
                    sbp.Width = newWidth;
                    changed = true;
                }
            }
        }
        if (changed) {
            this.DirtyLayout();
            this.PerformLayout();
        }
    }

    private void SetSimpleText(string? simpleText) {
        if (!this.showPanels && this.IsHandleCreated) {
            int wparam = SIMPLE_INDEX + NativeMethods.SBT_NOBORDERS;
            if (this.RightToLeft == RightToLeft.Yes) {
                wparam |= NativeMethods.SBT_RTLREADING;
            }

            //SendMessage(NativeMethods.SB_SETTEXT, wparam, simpleText);
            UnsafeNativeMethods.SendMessage(new HandleRef(this, this.Handle), NativeMethods.SB_SETTEXT, wparam, simpleText);
        }
    }

    /// <summary>
    ///     Sizes the panels appropriately. It looks at the SPRING AutoSize
    ///     property.
    /// </summary>
    /// <internalonly/>
    private void LayoutPanels() {
        StatusBarPanel panel;
        int barPanelWidth = 0;
        int springNum = 0;
        StatusBarPanel[] pArray = new StatusBarPanel[this.panels.Count];
        bool changed = false;

        for (int i = 0; i < pArray.Length; i++) {
            panel = (StatusBarPanel)this.panels[i]!;
            if (panel.AutoSize == StatusBarPanelAutoSize.Spring) {
                pArray[springNum] = panel;
                springNum++;
            }
            else {
                barPanelWidth += panel.Width;
            }
        }

        if (springNum > 0) {
            Rectangle rect = this.Bounds;
            int springPanelsLeft = springNum;
            int leftoverWidth = rect.Width - barPanelWidth;
            if (this.sizeGrip) {
                leftoverWidth -= this.SizeGripWidth;
            }
            int copyOfLeftoverWidth = unchecked((int)0x80000000);
            while (springPanelsLeft > 0) {
                int widthOfSpringPanel = leftoverWidth / springPanelsLeft;
                if (leftoverWidth == copyOfLeftoverWidth)
                    break;
                copyOfLeftoverWidth = leftoverWidth;

                for (int i = 0; i < springNum; i++) {
                    panel = pArray[i];
                    if (panel == null)
                        continue;

                    if (widthOfSpringPanel < panel.MinWidth) {
                        if (panel.Width != panel.MinWidth) {
                            changed = true;
                        }
                        panel.Width = panel.MinWidth;
                        pArray[i] = null!;
                        springPanelsLeft--;
                        leftoverWidth -= panel.MinWidth;
                    }
                    else {
                        if (panel.Width != widthOfSpringPanel) {
                            changed = true;
                        }
                        panel.Width = widthOfSpringPanel;
                    }
                }
            }
        }

        if (changed || this.layoutDirty) {
            this.ApplyPanelWidths();
        }
    }

    /// <summary>
    ///    <para>
    ///       Raises the <see cref='System.Windows.Forms.StatusBar.OnDrawItem'/>
    ///       event.
    ///    </para>
    /// </summary>
    protected virtual void OnDrawItem(StatusBarDrawItemEventArgs sbdievent) {
        EventHandler<StatusBarDrawItemEventArgs>? handler = (EventHandler<StatusBarDrawItemEventArgs>?)this.Events[EVENT_PANELCLICK];
        handler?.Invoke(this, sbdievent);
    }

    /// <summary>
    ///    <para>
    ///       Raises the <see cref='System.Windows.Forms.StatusBar.OnResize'/>
    ///       event.
    ///    </para>
    /// </summary>
    protected override void OnResize(EventArgs e) {
        this.Invalidate();
        base.OnResize(e);
    }

    /// <summary>
    ///    <para>
    ///       Returns a string representation for this control.
    ///    </para>
    /// </summary>
    public override string ToString() {
        string s = base.ToString();
        if (this.Panels != null) {
            s += ", Panels.Count: " + this.Panels.Count.ToString(CultureInfo.CurrentCulture);
            if (this.Panels.Count > 0)
                s += ", Panels[0]: " + this.Panels[0];
        }
        return s;
    }

    //call this when System.Windows.forms.toolTip is Associated with Statusbar....
    internal void SetToolTip(ToolTip t) {
        this.mainToolTip = t;
        this.toolTipSet = true;
    }

    internal void UpdateTooltip(StatusBarPanel? panel) {
        if (this.tooltips == null) {
            if (this.IsHandleCreated && !this.DesignMode) {
                //This shouldn't happen: tooltips should've already been set.  The best we can 
                //do here is reset it.
                this.tooltips = new ControlToolTip(this);
            }
            else {
                return;
            }
        }

        if (panel?.Parent == this && panel.ToolTipText.Length > 0) {
            int border = SystemInformation.Border3DSize.Width;
            ControlToolTip.Tool t = this.tooltips.GetTool(panel) ?? new();
            t.text = panel.ToolTipText;
            t.rect = new Rectangle(panel.Right - panel.Width + border, 0, panel.Width - border, this.Height);
            this.tooltips.SetTool(panel, t);
        }
        else {
            this.tooltips.SetTool(panel, null);
        }
    }

    private void UpdatePanelIndex() {
        int length = this.panels.Count;
        for (int i = 0; i < length; i++) {
            ((StatusBarPanel)this.panels[i]!).Index = i;
        }
    }

    /// <internalonly/>
    /// <summary>
    ///     Processes messages for ownerdraw panels.
    /// </summary>
    private void WmDrawItem(ref Message m) {
        NativeMethods.DRAWITEMSTRUCT dis = (NativeMethods.DRAWITEMSTRUCT)m.GetLParam(typeof(NativeMethods.DRAWITEMSTRUCT))!;

        int length = this.panels.Count;
        if (dis.itemID < 0 || dis.itemID >= length)
            Debug.Fail("OwnerDraw item out of range");

        StatusBarPanel panel = (StatusBarPanel)
                               this.panels[dis.itemID]!;

        Graphics g = Graphics.FromHdcInternal(dis.hDC);
        Rectangle r = Rectangle.FromLTRB(dis.rcItem.left, dis.rcItem.top, dis.rcItem.right, dis.rcItem.bottom);

        //The itemstate is not defined for a statusbar control
        this.OnDrawItem(new StatusBarDrawItemEventArgs(g, this.Font, r, dis.itemID, DrawItemState.None, panel, this.ForeColor, this.BackColor));
        g.Dispose();
    }

    /// <internalonly/>
    private void WmNotifyNMClick(NativeMethods.NMHDR note) {
        if (!this.showPanels) {
            return;
        }

        int size = this.panels.Count;
        int currentOffset = 0;
        int index = -1;
        for (int i = 0; i < size; i++) {
            StatusBarPanel panel = (StatusBarPanel)this.panels[i]!;
            currentOffset += panel.Width;
            if (this.lastClick.X < currentOffset) {
                // this is where the mouse was clicked.
                index = i;
                break;
            }
        }
        if (index != -1) {
            MouseButtons button = MouseButtons.Left;
            int clicks = 0;
            switch (note.code) {
                case NativeMethods.NM_CLICK:
                    button = MouseButtons.Left;
                    clicks = 1;
                    break;
                case NativeMethods.NM_RCLICK:
                    button = MouseButtons.Right;
                    clicks = 1;
                    break;
                case NativeMethods.NM_DBLCLK:
                    button = MouseButtons.Left;
                    clicks = 2;
                    break;
                case NativeMethods.NM_RDBLCLK:
                    button = MouseButtons.Right;
                    clicks = 2;
                    break;
            }

            Point pt = this.lastClick;
            StatusBarPanel panel = (StatusBarPanel)this.panels[index]!;

            StatusBarPanelClickEventArgs sbpce = new(panel,
                                                        button, clicks, pt.X, pt.Y);
            this.OnPanelClick(sbpce);
        }
    }

    private void WmNCHitTest(ref Message m) {
        int x = NativeMethods.Util.LOWORD(m.LParam);
        Rectangle bounds = this.Bounds;
        bool callSuper = true;

        // The default implementation of the statusbar
        //       : will let you size the form when it is docked on the bottom,
        //       : but when it is anywhere else, the statusbar will be resized.
        //       : to prevent that we provide a little bit a sanity to only
        //       : allow resizing, when it would resize the form.
        //
        if (x > bounds.X + bounds.Width - this.SizeGripWidth) {
            //Control parent = ParentInternal;
            Control? parent = this.Parent;
            if (parent is not null and Form) {
                FormBorderStyle bs = ((Form)parent).FormBorderStyle;

                if (bs != FormBorderStyle.Sizable
                    && bs != FormBorderStyle.SizableToolWindow) {
                    callSuper = false;
                }

                if (!((Form)parent).TopLevel || this.Dock != DockStyle.Bottom) {
                    callSuper = false;
                }

                if (callSuper) {
                    Control.ControlCollection children = parent.Controls;
                    int c = children.Count;
                    for (int i = 0; i < c; i++) {
                        Control ctl = children[i];
                        if (ctl != this && ctl.Dock == DockStyle.Bottom) {
                            if (ctl.Top > this.Top) {
                                callSuper = false;
                                break;
                            }
                        }
                    }
                }
            }
            else {
                callSuper = false;
            }
        }

        if (callSuper) {
            base.WndProc(ref m);
        }
        else {
            m.Result = (IntPtr)NativeMethods.HTCLIENT;
        }
    }

    /// <summary>
    ///    <para>
    ///       Base wndProc. All messages are sent to wndProc after getting filtered through
    ///       the preProcessMessage function. Inheriting controls should call base.wndProc
    ///       for any messages that they don't handle.
    ///    </para>
    /// </summary>
    protected override void WndProc(ref Message m) {
        switch (m.Msg) {
            case NativeMethods.WM_NCHITTEST:
                this.WmNCHitTest(ref m);
                break;
            case NativeMethods.WM_REFLECT + NativeMethods.WM_DRAWITEM:
                this.WmDrawItem(ref m);
                break;
            case NativeMethods.WM_NOTIFY:
            case NativeMethods.WM_NOTIFY + NativeMethods.WM_REFLECT:
                NativeMethods.NMHDR note = (NativeMethods.NMHDR)m.GetLParam(typeof(NativeMethods.NMHDR))!;
                switch (note.code) {
                    case NativeMethods.NM_CLICK:
                    case NativeMethods.NM_RCLICK:
                    case NativeMethods.NM_DBLCLK:
                    case NativeMethods.NM_RDBLCLK:
                        this.WmNotifyNMClick(note);
                        break;
                    default:
                        base.WndProc(ref m);
                        break;
                }
                break;

            default:
                base.WndProc(ref m);
                break;
        }
    }

    /// <summary>
    ///    <para>
    ///       The collection of StatusBarPanels that the StatusBar manages.
    ///       event.
    ///    </para>
    /// </summary>
    [ListBindable(false)]
    public class StatusBarPanelCollection : IList {
        private readonly StatusBar owner;
        /// A caching mechanism for key accessor
        /// We use an index here rather than control so that we don't have lifetime
        /// issues by holding on to extra references.
        private int lastAccessedIndex = -1;

        /// <summary>
        ///    <para>
        ///       Constructor for the StatusBarPanelCollection class
        ///    </para>
        /// </summary>
        public StatusBarPanelCollection(StatusBar owner) {
            this.owner = owner;
        }

        /// <summary>
        ///       This method will return an individual StatusBarPanel with the appropriate index.
        /// </summary>
        public virtual StatusBarPanel this[int index] {
            get {
                return (StatusBarPanel)this.owner.panels[index]!;
            }
            set {
#if NET6_0_OR_GREATER
                ArgumentNullException.ThrowIfNull(value);
#else
                if (value == null) {
                    throw new ArgumentNullException("StatusBarPanel");
                }
#endif

                this.owner.layoutDirty = true;

                if (value.Parent != null) {
                    throw new ArgumentException("Object already has parent.", nameof(value));
                }

                int length = this.owner.panels.Count;

                if (index < 0 || index >= length)
                    throw new ArgumentOutOfRangeException(nameof(index), "Index is out of range.");

                StatusBarPanel oldPanel = (StatusBarPanel)this.owner.panels[index]!;
                oldPanel.ParentInternal = null;
                value.ParentInternal = this.owner;
                if (value.AutoSize == StatusBarPanelAutoSize.Contents) {
                    value.Width = value.GetContentsWidth(true);
                }
                this.owner.panels[index] = value;
                value.Index = index;

                if (this.owner.ArePanelsRealized()) {
                    this.owner.PerformLayout();
                    value.Realize();
                }
            }
        }

        /// <internalonly/>
        object? IList.this[int index] {
            get {
                return this[index];
            }
            set {
                if (value is StatusBarPanel statusBarPanel) {
                    this[index] = statusBarPanel;
                }
                else {
                    throw new ArgumentException("Object is not a status bar panel.", nameof(value));
                }
            }
        }
        /// <summary>
        ///     <para>Retrieves the child control with the specified key.</para>
        /// </summary>
        public virtual StatusBarPanel? this[string key] {
            get {
                // We do not support null and empty string as valid keys.
                if (string.IsNullOrEmpty(key)) {
                    return null;
                }

                // Search for the key in our collection
                int index = this.IndexOfKey(key);
                if (this.IsValidIndex(index)) {
                    return this[index];
                }
                else {
                    return null;
                }
            }
        }

        /// <summary>
        ///    <para>
        ///       Returns an integer representing the number of StatusBarPanels
        ///       in this collection.
        ///    </para>
        /// </summary>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public int Count {
            get {
                return this.owner.panels.Count;
            }
        }

        /// <internalonly/>
        object ICollection.SyncRoot {
            get {
                return this;
            }
        }

        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {
                return false;
            }
        }

        /// <internalonly/>
        bool IList.IsFixedSize {
            get {
                return false;
            }
        }

        /// <summary>
        ///    <para>[To be supplied.]</para>
        /// </summary>
        public bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <summary>
        ///    <para>
        ///       Adds a StatusBarPanel to the collection.
        ///    </para>
        /// </summary>
        public virtual StatusBarPanel Add(string text) {
            StatusBarPanel panel = new() {
                Text = text
            };
            this.Add(panel);
            return panel;
        }

        /// <summary>
        ///    <para>
        ///       Adds a StatusBarPanel to the collection.
        ///    </para>
        /// </summary>
        public virtual int Add(StatusBarPanel value) {
            int index = this.owner.panels.Count;
            this.Insert(index, value);
            return index;
        }

        /// <internalonly/>
        int IList.Add(object? value) {
            if (value is StatusBarPanel statusBarPanel) {
                return this.Add(statusBarPanel);
            }
            else {
                throw new ArgumentException("Object is not a status bar panel.", nameof(value));
            }
        }

        /// <summary>
        ///    <para>[To be supplied.]</para>
        /// </summary>
        public virtual void AddRange(StatusBarPanel[] panels) {
#if NET6_0_OR_GREATER
            ArgumentNullException.ThrowIfNull(panels);
#else
            if (panels == null) {
                throw new ArgumentNullException(nameof(panels));
            }
#endif
            foreach (StatusBarPanel panel in panels) {
                this.Add(panel);
            }
        }

        /// <summary>
        ///    <para>[To be supplied.]</para>
        /// </summary>
        public bool Contains(StatusBarPanel panel) {
            return this.IndexOf(panel) != -1;
        }

        /// <internalonly/>
        bool IList.Contains(object? panel) {
            if (panel is StatusBarPanel statusBarPanel) {
                return this.Contains(statusBarPanel);
            }
            else {
                return false;
            }
        }

        /// <summary>
        ///     <para>Returns true if the collection contains an item with the specified key, false otherwise.</para>
        /// </summary>
        public virtual bool ContainsKey(string key) {
            return this.IsValidIndex(this.IndexOfKey(key));
        }

        /// <summary>
        ///    <para>[To be supplied.]</para>
        /// </summary>
        public int IndexOf(StatusBarPanel panel) {
            for (int index = 0; index < this.Count; ++index) {
                if (this[index] == panel) {
                    return index;
                }
            }
            return -1;
        }

        /// <internalonly/>
        int IList.IndexOf(object? panel) {
            if (panel is StatusBarPanel statusBarPanel) {
                return this.IndexOf(statusBarPanel);
            }
            else {
                return -1;
            }
        }

        /// <summary>
        ///     <para>The zero-based index of the first occurrence of value within the entire CollectionBase, if found; otherwise, -1.</para>
        /// </summary>
        public virtual int IndexOfKey(String key) {
            // Step 0 - Arg validation
            if (string.IsNullOrEmpty(key)) {
                return -1; // we dont support empty or null keys.
            }

            // step 1 - check the last cached item
            if (this.IsValidIndex(this.lastAccessedIndex)) {
                if (WindowsFormsUtils.SafeCompareStrings(this[this.lastAccessedIndex].Name, key, /* ignoreCase = */ true)) {
                    return this.lastAccessedIndex;
                }
            }

            // step 2 - search for the item
            for (int i = 0; i < this.Count; i++) {
                if (WindowsFormsUtils.SafeCompareStrings(this[i].Name, key, /* ignoreCase = */ true)) {
                    this.lastAccessedIndex = i;
                    return i;
                }
            }

            // step 3 - we didn't find it.  Invalidate the last accessed index and return -1.
            this.lastAccessedIndex = -1;
            return -1;
        }

        /// <summary>
        ///    <para>
        ///       Inserts a StatusBarPanel in the collection.
        ///    </para>
        /// </summary>
        public virtual void Insert(int index, StatusBarPanel value) {
            //check for the value not to be null
#if NET6_0_OR_GREATER
            ArgumentNullException.ThrowIfNull(value);
#else
            if (value == null)
                throw new ArgumentNullException(nameof(value));
#endif
            //end check

            this.owner.layoutDirty = true;
            if (value.Parent != this.owner && value.Parent != null)
                throw new ArgumentException("Object already has parent.", nameof(value));

            int length = this.owner.panels.Count;

            if (index < 0 || index > length)
                throw new ArgumentOutOfRangeException(nameof(index), "Index is out of range.");
            value.ParentInternal = this.owner;

            switch (value.AutoSize) {
                case StatusBarPanelAutoSize.None:
                case StatusBarPanelAutoSize.Spring:
                    break;
                case StatusBarPanelAutoSize.Contents:
                    value.Width = value.GetContentsWidth(true);
                    break;
            }

            this.owner.panels.Insert(index, value);
            this.owner.UpdatePanelIndex();

            this.owner.ForcePanelUpdate();
        }

        /// <internalonly/>
        void IList.Insert(int index, object? value) {
            if (value is StatusBarPanel statusBarPanel) {
                this.Insert(index, statusBarPanel);
            }
            else {
                throw new ArgumentException("Object is not a status bar panel.", nameof(value));
            }
        }

        /// <summary>
        ///     <para>Determines if the index is valid for the collection.</para>
        /// </summary>
        /// <internalonly/>
        private bool IsValidIndex(int index) {
            return (index >= 0) && (index < this.Count);
        }

        /// <summary>
        ///    <para>
        ///       Removes all the StatusBarPanels in the collection.
        ///    </para>
        /// </summary>
        public virtual void Clear() {
            this.owner.RemoveAllPanelsWithoutUpdate();
            this.owner.PerformLayout();
        }

        /// <summary>
        ///    <para>
        ///       Removes an individual StatusBarPanel in the collection.
        ///    </para>
        /// </summary>
        /// <exception cref="ArgumentNullException"><paramref name="value"/> is <c>null</c>.</exception>
        public virtual void Remove(StatusBarPanel value) {
            //check for the value not to be null
#if NET6_0_OR_GREATER
            ArgumentNullException.ThrowIfNull(value);
#else
            if (value == null) {
                throw new ArgumentNullException(nameof(value));
            }
#endif

            //end check

            if (value.Parent != this.owner) {
                return;
            }
            this.RemoveAt(value.Index);
        }

        /// <internalonly/>
        void IList.Remove(object? value) {
            if (value is StatusBarPanel statusBarPanel) {
                this.Remove(statusBarPanel);
            }
        }

        /// <summary>
        ///    <para>
        ///       Removes an individual StatusBarPanel in the collection at the given index.
        ///    </para>
        /// </summary>
        public virtual void RemoveAt(int index) {
            int length = this.Count;
            if (index < 0 || index >= length)
                throw new ArgumentOutOfRangeException(nameof(index), "Index is out of range.");

            // clear any tooltip
            //
            StatusBarPanel panel = (StatusBarPanel)this.owner.panels[index]!;

            this.owner.panels.RemoveAt(index);
            panel.ParentInternal = null;

            // this will cause the panels tooltip to be removed since it's no longer a child
            // of this StatusBar.
            //
            this.owner.UpdateTooltip(panel);

            // V#41207 - Microsoft, 4/1/1998 - We must reindex the panels after a removal...
            this.owner.UpdatePanelIndex();
            this.owner.ForcePanelUpdate();
        }
        /// <summary>
        ///     <para>Removes the child control with the specified key.</para>
        /// </summary>
        public virtual void RemoveByKey(string key) {
            int index = this.IndexOfKey(key);
            if (this.IsValidIndex(index)) {
                this.RemoveAt(index);
            }
        }

        /// <internalonly/>
        void ICollection.CopyTo(Array dest, int index) {
            this.owner.panels.CopyTo(dest, index);
        }

        /// <summary>
        ///    <para>
        ///       Returns the Enumerator for this collection.
        ///    </para>
        /// </summary>
        public IEnumerator GetEnumerator() {
            if (this.owner.panels != null) {
                return this.owner.panels.GetEnumerator();
            }
            else {
                return Array.Empty<StatusBarPanel>().GetEnumerator();
            }
        }
    }
    /// <summary>
    ///     This is a tooltip control that provides tips for a single
    ///     control. Each "tool" region is defined by a rectangle and
    ///     the string that should be displayed. This implementation
    ///     is based on System.Windows.Forms.ToolTip, but this control
    ///     is lighter weight and provides less functionality... however
    ///     this control binds to rectangular regions, instead of
    ///     full controls.
    /// </summary>
    private class ControlToolTip {
        public class Tool {
            public Rectangle rect = Rectangle.Empty;
            public string? text;
            internal nint id = -1;
        }

        private readonly Hashtable tools = [ ];
        private readonly ToolTipNativeWindow window;
        private readonly Control parent;
        private int nextId;

        /// <summary>
        ///    Creates a new ControlToolTip.
        /// </summary>
        public ControlToolTip(Control parent) {
            this.window = new ToolTipNativeWindow(this);
            this.parent = parent;
        }

        /// <summary>
        ///    Returns the createParams to create the window.
        /// </summary>
        protected static CreateParams CreateParams {
            get {
                NativeMethods.INITCOMMONCONTROLSEX icc = new() {
                    dwICC = NativeMethods.ICC_TAB_CLASSES
                };
                SafeNativeMethods.InitCommonControlsEx(icc);
                CreateParams cp = new() {
                    Parent = 0,
                    ClassName = NativeMethods.TOOLTIPS_CLASS
                };
                cp.Style |= NativeMethods.TTS_ALWAYSTIP;
                cp.ExStyle = 0;
                cp.Caption = null;
                return cp;
            }
        }

        public IntPtr Handle {
            get {
                if (this.window.Handle == IntPtr.Zero) {
                    this.CreateHandle();
                }
                return this.window.Handle;
            }
        }

        private bool IsHandleCreated {
            get { return this.window.Handle != IntPtr.Zero; }
        }

        private void AssignId(Tool tool) {
            tool.id = (IntPtr)this.nextId;
            this.nextId++;
        }

        /// <summary>
        ///    Sets the tool for the specified key. Keep in mind
        ///    that as soon as setTool is called, the handle for
        ///    the ControlToolTip is created, and the handle for
        ///    the parent control is also created. If the parent
        ///    handle is recreated in the future, all tools must
        ///    be re-added. The old tool for the specified key
        ///    will be removed. Passing null in for the
        ///    tool parameter will result in the tool
        ///    region being removed.
        /// </summary>
        public void SetTool(object? key, Tool? tool) {
            if (key is null) {
                return;
            }

            bool remove = false;
            bool add = false;
            bool update = false;

            Tool? toRemove = null;
            if (this.tools.ContainsKey(key)) {
                toRemove = (Tool?)this.tools[key];
            }

            if (toRemove != null) {
                remove = true;
            }
            if (tool != null) {
                add = true;
            }
            if (tool != null && toRemove != null
                && tool.id == toRemove.id) {
                update = true;
            }

            if (update) {
                this.UpdateTool(tool!);
            }
            else {
                if (remove) {
                    this.RemoveTool(toRemove!);
                }
                if (add) {
                    this.AddTool(tool!);
                }
            }

            if (tool != null) {
                this.tools[key] = tool;
            }
            else {
                this.tools.Remove(key);
            }
        }

        /// <summary>
        ///    Returns the tool associated with the specified key,
        ///    or null if there is no area.
        /// </summary>
        public Tool GetTool(object key) {
            return (Tool)this.tools[key]!;
        }

        private void AddTool(Tool tool) {
            if (tool?.text?.Length > 0) {
                int ret;
                StatusBar p = (StatusBar)this.parent;

                if (p.ToolTipSet) {
                    //ret = (int)UnsafeNativeMethods.SendMessage(new HandleRef(p.MainToolTip, p.MainToolTip.Handle), NativeMethods.TTM_ADDTOOL, 0, GetTOOLINFO(tool));
                    ret = (int)UnsafeNativeMethods.SendMessage(new HandleRef(p.MainToolTip, (IntPtr)TooltipHandleProp.GetValue(p.mainToolTip)!), NativeMethods.TTM_ADDTOOL, 0, this.GetTOOLINFO(tool));
                }
                else {
                    ret = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, this.Handle), NativeMethods.TTM_ADDTOOL, 0, this.GetTOOLINFO(tool));
                }
                if (ret == 0) {
                    throw new InvalidOperationException("Could not add to status bar.");
                }
            }
        }
        private void RemoveTool(Tool tool) {
            if (tool?.text?.Length > 0 && checked((int)tool.id) >= 0) {
                UnsafeNativeMethods.SendMessage(new HandleRef(this, this.Handle), NativeMethods.TTM_DELTOOL, 0, this.GetMinTOOLINFO(tool));
            }
        }
        private void UpdateTool(Tool tool) {
            if (tool?.text?.Length > 0 && checked((int)tool.id) >= 0) {
                UnsafeNativeMethods.SendMessage(new HandleRef(this, this.Handle), NativeMethods.TTM_SETTOOLINFO, 0, this.GetTOOLINFO(tool));
            }
        }

        /// <summary>
        ///    Creates the handle for the control.
        /// </summary>
        protected void CreateHandle() {
            if (this.IsHandleCreated) {
                return;
            }

            this.window.CreateHandle(CreateParams);
            SafeNativeMethods.SetWindowPos(new HandleRef(this, this.Handle), NativeMethods.HWND_TOPMOST,
                                 0, 0, 0, 0,
                                 NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOSIZE |
                                 NativeMethods.SWP_NOACTIVATE);

            // Setting the max width has the added benefit of enabling multiline
            // tool tips!
            //
            UnsafeNativeMethods.SendMessage(new HandleRef(this, this.Handle), NativeMethods.TTM_SETMAXTIPWIDTH, 0, SystemInformation.MaxWindowTrackSize.Width);
        }

        /// <summary>
        ///    Destroys the handle for this control.
        /// </summary>
        protected void DestroyHandle() {
            if (this.IsHandleCreated) {
                this.window.DestroyHandle();
                this.tools.Clear();
            }
        }

        /// <summary>
        ///    Disposes of the component.  Call dispose when the component is no longer needed.
        ///    This method removes the component from its container (if the component has a site)
        ///    and triggers the dispose event.
        /// </summary>
        public void Dispose() {
            this.DestroyHandle();
        }

        /// <summary>
        ///     Returns a new instance of the TOOLINFO_T structure with the minimum
        ///     required data to uniquely identify a region. This is used primarily
        ///     for delete operations. NOTE: This cannot force the creation of a handle.
        /// </summary>
        private NativeMethods.TOOLINFO_T GetMinTOOLINFO(Tool tool) {
            NativeMethods.TOOLINFO_T ti = new() {
                cbSize = Marshal.SizeOf(typeof(NativeMethods.TOOLINFO_T)),
                hwnd = this.parent.Handle
            };

            if (checked((int)tool.id) < 0) {
                this.AssignId(tool);
            }
            StatusBar p = (StatusBar)this.parent;
            if (p?.ToolTipSet == true) {
                ti.uId = this.parent.Handle;
            }
            else {
                ti.uId = tool.id;
            }
            return ti;
        }

        /// <summary>
        ///     Returns a detailed TOOLINFO_T structure that represents the specified
        ///     region. NOTE: This may force the creation of a handle.
        /// </summary>
        private NativeMethods.TOOLINFO_T GetTOOLINFO(Tool tool) {
            NativeMethods.TOOLINFO_T ti = this.GetMinTOOLINFO(tool);
            ti.cbSize = Marshal.SizeOf(typeof(NativeMethods.TOOLINFO_T));
            ti.uFlags |= NativeMethods.TTF_TRANSPARENT | NativeMethods.TTF_SUBCLASS;

            // RightToLeft reading order
            //
            Control richParent = this.parent;
            if (richParent != null && richParent.RightToLeft == RightToLeft.Yes) {
                ti.uFlags |= NativeMethods.TTF_RTLREADING;
            }

            ti.lpszText = tool.text;
            ti.rect = NativeMethods.RECT.FromXYWH(tool.rect.X, tool.rect.Y, tool.rect.Width, tool.rect.Height);
            return ti;
        }

        ~ControlToolTip() {
            this.DestroyHandle();
        }

        /// <summary>
        ///    WNDPROC
        /// </summary>
        protected void WndProc(ref Message msg) {
            switch (msg.Msg) {
                case NativeMethods.WM_SETFOCUS:
                    // bug 120872, the COMCTL StatusBar passes WM_SETFOCUS on to the DefWndProc, so
                    // it will take keyboard focus.  We don't want it doing this, so we eat
                    // the message.
                    //
                    return;
                default:
                    this.window.DefWndProc(ref msg);
                    break;
            }
        }

        private class ToolTipNativeWindow : NativeWindow {
            readonly ControlToolTip? control;

            internal ToolTipNativeWindow(ControlToolTip? control) {
                this.control = control;
            }

            protected override void WndProc(ref Message m) {
                this.control?.WndProc(ref m);
            }
        }
    }

    private static readonly PropertyInfo TooltipHandleProp = typeof(ToolTip).GetProperty("Handle", BindingFlags.Instance | BindingFlags.NonPublic)
        ?? throw new Exception("Could not find property.");
}
#endif
