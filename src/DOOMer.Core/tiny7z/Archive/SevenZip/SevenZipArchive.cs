// -----------------
// <auto-generated/>
// -----------------

#nullable disable
namespace pdj.tiny7z.Archive;

using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using pdj.tiny7z.Common;

/// <summary>
/// Main 7zip archive class to handle reading and writing into .7z archive files.
/// </summary>
public class SevenZipArchive : Archive, IDisposable {
    #region Public Constants and Structs
    /// <summary>
    /// 7zip file signature
    /// </summary>
    internal static readonly Byte[] kSignature = [(Byte)'7', (Byte)'z', 0xBC, 0xAF, 0x27, 0x1C];

    /// <summary>
    /// 7zip file archive version
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct ArchiveVersion {
        [MarshalAs(UnmanagedType.U1)]
        public Byte Major;   // now = 0

        [MarshalAs(UnmanagedType.U1)]
        public Byte Minor;   // now = 2
    };

    /// <summary>
    /// Header part that tells where the actual header starts at the end of the file usually
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct StartHeader {
        [MarshalAs(UnmanagedType.U8)]
        public UInt64 NextHeaderOffset;

        [MarshalAs(UnmanagedType.U8)]
        public UInt64 NextHeaderSize;

        [MarshalAs(UnmanagedType.U4)]
        public UInt32 NextHeaderCRC;
    }

    /// <summary>
    /// Signature header of a valid 7zip file
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct SignatureHeader {
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 6)]
        public Byte[] Signature;

        public ArchiveVersion ArchiveVersion;

        [MarshalAs(UnmanagedType.U4)]
        public UInt32 StartHeaderCRC;

        public StartHeader StartHeader;
    }
    #endregion Public Constants and Structs

    #region Internal Properties
    internal SevenZipHeader Header { get; set; }
    #endregion Internal Properties

    #region Private Fields
    SignatureHeader signatureHeader;
    Stream stream;
    #endregion Private Fields

    #region Public Constructors
    /// <summary>
    /// Construct a 7zip file with an existing stream
    /// </summary>
    public SevenZipArchive(Stream stream, FileAccess fileAccess) {
        this.stream = stream;

        if (fileAccess == FileAccess.Read) {
            Trace.TraceInformation("Open 7zip archive for reading.");
            this.Open();
            return;
        }

        if (fileAccess == FileAccess.Write) {
            Trace.TraceInformation("Open 7zip archive for writing.");
            this.Create();
            return;
        }

        throw new ArgumentException("`fileAccess` must be either `Read` or `Write`.");
    }
    #endregion Public Constructors

    #region Public Methods
    /// <summary>
    /// IDiposable interface requirement
    /// </summary>
    public void Dispose() {
        this.Close();
        GC.SuppressFinalize(this);
    }

    /// <summary>
    /// Returns an extractor object to retrieve files from
    /// </summary>
    /// <returns></returns>
    public override IExtractor Extractor() {
        if (this.stream is null) {
            throw new SevenZipException("SevenZipArchive object is either uninitialized or closed.");
        }
        return new SevenZipExtractor(stream, this.Header);
    }

    /// <summary>
    /// Returns a compressor object to compress files into
    /// </summary>
    /// <returns></returns>
    public override ICompressor Compressor() {
        if (this.stream is null) {
            throw new SevenZipException("SevenZipArchive object is either uninitialized or closed.");
        }
        return new SevenZipCompressor(stream, this.Header);
    }

    /// <summary>
    /// Close current archive and stream. Archive is committed after this
    /// </summary>
    public void Close() {
        this.signatureHeader = default;
        if (this.stream is not null) {
            this.stream.Close();
            this.stream.Dispose();
            this.stream = default!;
        }
        this.Header = default!;
        this.IsValid = default;
    }
    #endregion Public Methods

    #region Private Methods
    /// <summary>
    /// Open an existing 7zip file for reading
    /// </summary>
    private void Open() {
        SignatureHeader sig = stream.ReadStruct<SignatureHeader>();
        if (!sig.Signature.SequenceEqual(kSignature)) {
            throw new SevenZipException("File is not a valid 7zip file.");
        }

        this.signatureHeader = sig;

        // some debug info

        Trace.TraceInformation("Opening 7zip file:");
        Trace.Indent();

        try {
            Trace.TraceInformation($"Version: {sig.ArchiveVersion.Major}.{sig.ArchiveVersion.Minor}");
            Trace.TraceInformation($"StartHeaderCRC: {sig.StartHeaderCRC.ToString("X8")}");
            Trace.TraceInformation($"NextHeaderOffset: {sig.StartHeader.NextHeaderOffset}");
            Trace.TraceInformation($"NextHeaderCRC: {sig.StartHeader.NextHeaderCRC.ToString("X8")}");
            Trace.TraceInformation($"NextHeaderSize: {sig.StartHeader.NextHeaderSize}");
            Trace.TraceInformation($"All headers: " + (sig.StartHeader.NextHeaderSize + (uint)Marshal.SizeOf(sig)) + " bytes");

            {
                uint crc32 = new CRC().Calculate(sig.StartHeader.GetByteArray()).Result;
                if (crc32 != sig.StartHeaderCRC) {
                    throw new SevenZipException("StartHeaderCRC mismatch: " + crc32.ToString("X8"));
                }
            }

            // buffer header in memory for further processing

            byte[] buffer = new byte[sig.StartHeader.NextHeaderSize];
            stream.Seek((long)sig.StartHeader.NextHeaderOffset, SeekOrigin.Current);
            if (stream.Read(buffer, 0, (int)sig.StartHeader.NextHeaderSize) != (int)sig.StartHeader.NextHeaderSize) {
                throw new SevenZipException("Reached end of file before end of header.");
            }

            {
                uint crc32 = new CRC().Calculate(buffer).Result;
                if (crc32 != sig.StartHeader.NextHeaderCRC) {
                    throw new SevenZipException("StartHeader.NextHeaderCRC mismatch: " + crc32.ToString("X8"));
                }
            }

            // initiate header parsing

            Trace.TraceInformation("Parsing 7zip file header:");
            Header = new SevenZipHeader(new MemoryStream(buffer));
            Header.Parse();

            // decompress encoded header if found

            if (Header.RawHeader == null && Header.EncodedHeader != null) {
                Trace.TraceInformation("Encoded header detected, decompressing.");
                Stream newHeaderStream = new MemoryStream();
                (new SevenZipStreamsExtractor(stream, Header.EncodedHeader)).Extract(0, newHeaderStream, null);

                Trace.TraceInformation("Parsing decompressed header:");
                newHeaderStream.Position = 0;
                SevenZipHeader
                    newHeader = new SevenZipHeader(newHeaderStream);
                newHeader.Parse();
                Header = newHeader;
            }

            IsValid = true;
        }
        finally {
            Trace.Unindent();
            Trace.TraceInformation("Done parsing 7zip file header.");
        }
    }

    /// <summary>
    /// Create a new 7zip file for writing
    /// </summary>
    private void Create() {
        this.signatureHeader = new SignatureHeader() {
            Signature = kSignature.ToArray(),
            ArchiveVersion = new ArchiveVersion() {
                Major = 0,
                Minor = 2,
            },
        };
        stream.Write(this.signatureHeader.GetByteArray(), 0, Marshal.SizeOf(this.signatureHeader));

        this.Header = new SevenZipHeader(null, true);
    }
    #endregion Private Methods
}
